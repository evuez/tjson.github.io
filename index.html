---
layout: default
title: "TJSON: Tagged JSON with rich type annotations"
---

<div class="container">
  <div class="row">
    <div class="col-lg-12">
      <div class="lead text-xs-center">
        <p>
          <strong>DRAFT:</strong> This format is still in a draft state and subject to change!
        </p>
      </div>
      <div id="introduction">
        <p>
          <strong>TJSON</strong> (Tagged JSON) is a standard tagging scheme for richly typed data
          stored inside of <a href="http://www.json.org">JSON</a> strings. It augments the existing
          types already present in JSON in a way that's both unobtrusive and fully syntactically
          compatible with existing JSON (i.e all TJSON documents are valid JSON documents and can
          be understood by existing JSON parsers)
        </p>
        <p>
          It codifies ad hoc practices already commonly seen throughout JSON into a standard format
          for rich data which is self-describing, fully transcodable, and easy to canonicalize.
        </p>
        <p>
          TJSON supports the following data types:
        </p>
        <ul>
          <li>
            <strong>UTF-8 Strings:</strong>
            Strings in TJSON work just like they do in regular JSON, but carry a mandatory type tag.
          </li>
          <li>
            <strong>Binary Data:</strong>
            First-class support for 8-bit clean binary data, encoded in a variety of formats
            including hexadecimal and Base64url.
          </li>
          <li>
            <strong>Integers:</strong>
            Integers in TJSON are variable length, are guaranteed to avoid floating point conversions,
            and can be readily disambiguated from floating points. Since they are stored in strings,
            they avoid common problems with floating point overflow which occur when working with
            large numbers serialized in JSON.
          </li>
          <li>
            <strong>Floating points:</strong>
            Floating points in TJSON are identical to JSON, but avoid pitfalls involving certain
            libraries coercing them to integers and can always be disambiguated from integers.
          </li>
          <li>
            <strong>Timestamps:</strong>
            TJSON has a first-class type for representing date/time timestamp values,
            serialized as a subset of RFC 3339 (an ISO 8601-alike).
          </li>

          <li>
            <strong>Value types:</strong>
            TJSON supports the <em>true</em>, <em>false</em>, and <em>null</em> values from JSON.
          </li>
          <li>
            <strong>Arrays:</strong>
            Lists of values; identical to JSON.
          </li>
          <li>
            <strong>Objects:</strong>
            Name/value dictionaries; identical to JSON with UTF-8 String or Binary Data keys.
          </li>
        </ul>
      </div>

      <div class="subsection">
        <h2 class="page-header">Strings</h2>
        <p>
          In TJSON, all string literals begin with a mandatory tag, which consists of a small
          sequence of alphanumeric characters followed by a "<strong>:</strong>" character.
          To encode a Unicode string as seen in JSON as a TJSON string, add the
          <strong>s:</strong> prefix:
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">s:</span>Hello world&quot;
        </div>
        <p>
          Note that this prefix is <em>mandatory</em> in TJSON and prevents any cross-domain
          ambiguities between tagged and untagged strings. Parsers which encounter an untagged
          string should raise an exception.
        </p>
        <p>
          Unlike JSON, TJSON mandates the use of
          <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> encoding for all strings.
          Other Unicode encodings (e.g. UCS-2 as seen in JavaScript) are expressly disallowed.
          All TJSON documents should be valid UTF-8, and parsers should reject documents that
          fail to decode as UTF-8.
        </p>
      </div>

      <div class="subsection">
        <h2 class="page-header">Binary Data</h2>
        <p>
          TJSON supports multiple different formats for encoding 8-bit clean binary data.
          Decoders are encouraged to support them all. The default is
          <strong>Base64url</strong>,
          however encoders can be configured with alternative, potentially more visually
          appealing or well-recognized encodings for specific fields.
        </p>

        <h3>Hexadecimal (a.k.a. Base16)</h3>
        <p>
          Encodes binary data in lower-case hexadecimal format:
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">b16:</span>48656c6c6f2c20776f726c6421&quot;
        </div>
        <p>
          TJSON parsers should expressly reject the use of any upper case Base32 characters
          and fail with an exception.
        </p>
        <p>
          TJSON parsers should expressly reject the use of any upper case hexadecimal characters
          and fail with an exception.
        </p>

        <h3>Base32</h3>
        <p>
          Encodes binary data in "base32" format as specified in
          <a href="https://tools.ietf.org/html/rfc4648">RFC 4648</a>:
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">b32:</span>jbswy3dpfqqho33snrscc&quot;
        </div>
        <p>
          The encoded data should <em>NOT</em> be padded with "<b>=</b>" characters as it's stored
          within a quote-delimited string so its length is known in advance.
        </p>

        <h3>Base64url</h3>
        <p>
          Encodes binary data in "base64url" format as specified in
          <a href="https://tools.ietf.org/html/rfc4648">RFC 4648</a>:
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">b64:</span>SGVsbG8sIHdvcmxkIQ&quot;
        </div>
        <p>
          The encoded data should <em>NOT</em> be padded with "<b>=</b>" characters as it's stored
          within a quote-delimited string so its length is known in advance.
        </p>
        <p>
          The non-URL safe variant of Base64 is not supported by TJSON and should be rejected by
          parsers (i.e. if it contains the "<b>+</b>" or "<b>/</b>" characters it should be
          rejected)
        </p>
      </div>

      <div class="subsection">
        <h2 class="page-header">Numeric Types</h2>
        <p>
          TJSON supports both integers and floating point numbers in separate formats that can
          always be disambiguated.
        </p>
        <h3>Integers</h3>
        <p>
          In TJSON, integers are stored as strings, sidestepping integer precision issues with
          JSON parsers that do floating point conversions.
        </p>
        <p>
          The following is an example of a <strong>signed integer</strong>, which can be any value
          in the range <em>-(2**63)</em> to <em>(2**63)-1</em>.
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">i:</span>42&quot;
        </div>
        <p>
          The following is an example of an <strong>unsigned integer</strong>, which can be any value
          in the range <em>0</em> to <em>(2**64)-1</em>:
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">u:</span>18446744073709551615&quot;
        </div>
        <p>
          Integers otherwise utilize the <em>int</em> syntax as described in the JSON specification.
        </p>
        <h3>Floating Points</h3>
        <p>
          Floating points use the native number literal syntax provided by JSON and are not stored
          as a tagged string:
        </p>
        <div class="syntax-example">0.42</div>
        <p>
          TJSON libraries should ensure that the resulting type for any such literals is a float.
        </p>
      </div>

      <div class="subsection">
        <h2 class="page-header">Timestamp</h2>
        <p>
          TJSON adds a literal syntax for timestamp values. The format is based on
          <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>, however the
          use of the UTC time zone identifier "<b>Z</b>" is mandatory (i.e. all
          timestamps are Z-normalized):
        </p>
        <div class="syntax-example">
          &quot;<span class="tag-prefix">t:</span>2016-10-02T07:31:51Z&quot;
        </div>
        <p>
          TJSON parsers should expressly reject the use of other time zone identifiers
          and fail with an exception.
        </p>
      </div>

      <div class="subsection">
        <h2 class="page-header">Objects</h2>
        <p>
          Objects (name/value dictionaries) use the same syntax in TJSON, but the name literal
          is restricted to being either a UTF-8 String or Binary Data:
        </p>

        <h3>UTF-8 String Member Name</h3>
        <div class="syntax-example">
          {&quot;<span class="tag-prefix">s:</span>key&quot;: ...}
        </div>

        <h3>Binary Data Member Name</h3>
        <div class="syntax-example">
          {&quot;<span class="tag-prefix">b64:</span>YmluYXJ5IGtleQ&quot;: ...}
        </div>

        <p>
          TJSON parsers should expressly reject the use of other types as member names.
        </p>

        <p>
          Member names in TJSON must be distinct. The use of the same member name more
          than once in the same object is an error.
        </p>
      </div>
    </div>
  </div>
</div>
